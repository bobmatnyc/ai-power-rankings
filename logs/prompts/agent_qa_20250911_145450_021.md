---
timestamp: 2025-09-11T14:54:50.021163
type: agent_qa
metadata: {"agent_type": "qa", "agent_id": "qa_194728ac-59b9-4cc7-9b55-58e67597b96b", "session_id": "194728ac-59b9-4cc7-9b55-58e67597b96b", "delegation_context": {"description": "Test database integration", "timestamp": "2025-09-11T14:54:50.020319"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: qa
<!-- Last Updated: 2025-08-07 16:21:04 | Auto-updated by: qa -->

<!-- MEMORY LIMITS: 8KB max | 10 sections max | 15 items per section -->

## Project Context
ai-power-rankings: node_js (with react, typescript) single page application
- Main modules: types, contexts, app, app/rss.xml
- Uses: @marsidev/react-turnstile, @radix-ui/react-checkbox, @radix-ui/react-collapsible
- Testing: @testing-library/jest-dom
- Key patterns: Async Programming

## Project Architecture
- Single Page Application with node_js implementation
- Main directories: src, docs
- Core modules: types, contexts, app, app/rss.xml

## Coding Patterns Learned
- Node.js project: use async/await, ES6+ features
- React patterns: component composition, hooks usage
- React patterns: component composition, hooks usage
- React patterns: component composition, hooks usage
- Project uses: Async Programming

## Implementation Guidelines
- Use pnpm for dependency management
- Write tests using @testing-library/jest-dom
- Use build tools: test, test:watch
- Key config files: package.json

## Domain-Specific Knowledge
<!-- Agent-specific knowledge for ai-power-rankings domain -->
- Key project terms: rankings, types, methodology, admin

## Effective Strategies
<!-- Successful approaches discovered through experience -->

## Common Mistakes to Avoid
- Avoid callback hell - use async/await consistently
- Don't commit node_modules - ensure .gitignore is correct
- Don't skip test isolation - ensure tests can run independently

## Integration Points
- REST API integration pattern

## Performance Considerations
- Leverage event loop - avoid blocking operations
- Use streams for large data processing
- Use React.memo for expensive component renders

## Current Technical Context
- Tech stack: node_js, @marsidev/react-turnstile, @radix-ui/react-checkbox
- API patterns: REST API
- Key dependencies: @builder.io/partytown, @hookform/resolvers, @marsidev/react-turnstile, @next/third-parties
- Documentation: README.md, CHANGELOG.md, docs/SITEMAP-SUBMISSION.md

## Recent Learnings
<!-- Most recent discoveries and insights -->
- **Testing Commands**: pnpm run test, type-check, lint, ci:local
- **JSON Validation**: All data files must be valid JSON
- **TypeScript Strict**: No any types, 100% type safety required
- **Pre-deploy Checks**: Always run pnpm run pre-deploy before production
- **Data Integrity**: Validate rankings scores (0-100), dates (ISO 8601)


INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Task: Test hybrid JSON/PostgreSQL system with fallback
Agent: QA

Structural Requirements:
  Objective: Validate the hybrid database system works correctly
  Inputs:
    - Database configuration in /src/lib/db/
    - Repository pattern in /src/lib/db/repositories/
    - Environment configuration in .env.local
  Falsifiable Success Criteria:
    - Environment variables load from .env files correctly
    - System works in JSON mode when USE_DATABASE=false
    - Database connection can be established (if credentials provided)
    - Repository pattern correctly switches between modes
    - Data integrity maintained in both modes
    - Performance stays under 100ms for all operations
  Testing Requirements: MANDATORY - Run all tests and provide results
  Constraints:
    Performance: All operations must complete in <100ms
    Architecture: Repository pattern must work in both modes
    Security: No credentials should be exposed in logs
  Verification: Provide test output with pass/fail for each scenario

Test scenarios:
1. Test environment variable loading from .env files
2. Test JSON mode (USE_DATABASE=false)
3. Test repository pattern with JSON backend
4. Test data reading and writing in JSON mode
5. Verify performance benchmarks
6. Test error handling when database is unavailable
7. Validate TypeScript types are correct

Run the tests and provide comprehensive output showing all scenarios.